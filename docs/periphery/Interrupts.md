## Прерывания в STM32

### Общая информация о прерываниях

STM32 использует векторную модель прерываний (NVIC - Nested Vectored Interrupt Controller) для обработки прерываний от периферийных устройств. Прерывания могут быть классифицированы следующим образом:

#### Типы прерываний:
1. **Внутренние прерывания** - возникают внутри микроконтроллера
2. **Внешние прерывания** - поступают с внешних пинов
3. **Прерывания периферии** - от периферийных устройств (таймеры, UART, GPIO и др.)

#### Приоритеты прерываний:
- **Прерывания с высоким приоритетом** - обрабатываются первыми
- **Прерывания с низким приоритетом** - обрабатываются после высокоприоритетных
- **Конфигурируемые приоритеты** - могут быть установлены программно

### Прерывания TIM6

TIM6 поддерживает следующие типы прерываний:

#### Основные прерывания TIM6:
1. **Прерывание по обновлению (Update Interrupt)** - генерируется при переполнении счетчика
2. **Прерывание по триггеру (Trigger Interrupt)** - используется при синхронизации

#### Регистры управления прерываниями:
- **DIER (DMA/Interrupt Enable Register)** - управление разрешением прерываний
- **SR (Status Register)** - флаги состояния прерываний
- **NVIC** - контроллер прерываний для настройки приоритетов

### Пример простейшей реализации прерываний

#### 1. Инициализация прерываний:
```c
// Включение тактирования TIM6 и GPIO
RCC->APB1ENR |= RCC_APB1ENR_TIM6EN;
RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN; // Для примера

// Настройка предделителя и перезагрузки
TIM6->PSC = 7199; // Предделитель 7200
TIM6->ARR = 999;  // Значение перезагрузки

// Разрешение прерывания по обновлению
TIM6->DIER |= TIM_DIER_UIE;

// Включение таймера
TIM6->CR1 |= TIM_CR1_CEN;

// Настройка NVIC для TIM6
NVIC_EnableIRQ(TIM6_IRQn);
NVIC_SetPriority(TIM6_IRQn, 0);
```

#### 2. Обработчик прерывания:
```c
void TIM6_IRQHandler(void) {
    // Проверка флага прерывания по обновлению
    if (TIM6->SR & TIM_SR_UIF) {
        // Очистка флага прерывания
        TIM6->SR &= ~TIM_SR_UIF;
        
        // Ваша логика обработки прерывания
        // Например, увеличение счетчика или изменение состояния LED
    }
}
```

#### 3. Упрощенная версия для симулятора:
Для симулятора можно реализовать упрощенную версию прерываний:

```c
// Функция для обработки прерываний TIM6
void handle_tim6_interrupt() {
    // Проверяем, разрешено ли прерывание по обновлению
    if (tim6_dier & TIM_DIER_UIE) {
        // Устанавливаем флаг прерывания
        tim6_sr |= TIM_SR_UIF;
        
        // В симуляторе можно просто вызвать обработчик прерывания
        // или добавить его в очередь прерываний
        if (interrupt_enabled(TIM6_IRQn)) {
            // Генерация прерывания (в зависимости от реализации симулятора)
            generate_interrupt(TIM6_IRQn);
        }
    }
}

// Функция для проверки и обработки прерываний
void check_tim6_interrupts() {
    // Если флаг прерывания установлен и прерывание разрешено
    if ((tim6_sr & TIM_SR_UIF) && (tim6_dier & TIM_DIER_UIE)) {
        // Обработка прерывания
        handle_tim6_interrupt();
    }
}
```

### Рекомендации по реализации в симуляторе

1. **Простая реализация**:
   - Использовать флаги в регистре SR для отслеживания состояния прерываний
   - Реализовать проверку разрешения прерываний в DIER
   - Поддерживать очередь прерываний для симуляции реального поведения

2. **Упрощенная модель**:
   - Для симулятора можно использовать таймер с задержкой вместо реальных прерываний
   - Использовать системные таймеры для генерации событий
   - Реализовать минимальную логику обработки прерываний

3. **Пример упрощенной реализации**:
```c
// Упрощенная реализация для симулятора
void sim_tim6_update() {
    // Увеличиваем счетчик
    tim6_cnt++;
    
    // Проверяем на переполнение
    if (tim6_cnt >= tim6_arr) {
        tim6_cnt = 0; // Сброс счетчика
        
        // Установка флага прерывания
        tim6_sr |= TIM_SR_UIF;
        
        // Если прерывание разрешено, генерируем его
        if (tim6_dier & TIM_DIER_UIE) {
            // В симуляторе можно просто установить флаг
            // или вызвать соответствующую функцию
            simulation_interrupt(TIM6_IRQn);
        }
    }
}
```
