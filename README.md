

# Техническое задание на разработку симулятора микроконтроллера STM32F103C8T6

![Файл с документацией](docs/doc_stm32.pdf) - тут написано много, в том числе и много лишнего, нужно выбирать
## 1. Введение

Настоящий документ определяет требования к разработке программного симулятора микроконтроллера STM32F103C8T6 (плата Blue Pill) в рамках курса «Программирование встроенных систем» (весна 2026, Университет ИТМО). Симулятор предназначен для исполнения скомпилированного кода для указанного микроконтроллера на хостовой машине, моделирования работы его периферийных устройств и последующей интеграции с облачной лабораторией ITMO.clab.

## 2. Назначение разработки

Симулятор должен позволять:
- выполнять бинарные файлы прошивки (формат .bin) для STM32F103C8T6 в среде Linux (или WSL) без наличия физической платы;
- моделировать работу центрального процессора (Cortex‑M3), памяти и набора периферийных блоков (GPIO, таймер, UART, контроллер прерываний) с точностью, достаточной для выполнения учебных лабораторных работ;
- предоставлять внешний интерфейс (через микросервис) для автоматического приёма заданий и возврата результатов, что позволит использовать симулятор в облачной лаборатории;
- служить инструментом для изучения архитектуры микроконтроллера, системы команд и принципов работы встроенного ПО.

## 3. Заинтересованные лица

При формировании требований учтены интересы следующих сторон:

| Роль                                                      | Интересы / ожидания                                                                                                                                       |
| --------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Разработчик симулятора (студент)                          | Понятная модульная архитектура, возможность параллельной работы над ядром и периферией, наличие документации и тестов.                                    |
| Преподаватель / заказчик                                  | Соответствие поведения симулятора реальному микроконтроллеру, возможность автоматической проверки студенческих работ, качественная пояснительная записка. |
| Администратор облачной лаборатории                        | Простота развёртывания (контейнеризация), устойчивость при множественных одновременных запусках, наличие метрик и логов (OpenTelemetry).                  |
| Конечный пользователь (студент, выполняющий лабораторные) | Интуитивно понятный способ загрузки прошивки, вывод данных UART в консоль, приемлемое быстродействие.                                                     |

## 4. Требования к программе

### 4.1. Функциональные требования

#### 4.1.1. Ядро симулятора (язык Си)
- Загружать бинарный образ прошивки в симулируемую Flash-память.
- Поддерживать карту памяти целевого микроконтроллера:
  - Flash: `0x08000000 – 0x0800FFFF` (64 КБ);
  - SRAM: `0x20000000 – 0x20004FFF` (20 КБ);
  - Периферийные регистры — в соответствующих диапазонах адресов.
- Реализовать систему команд в соответствии с документом **PM0056** (Programming manual for STM32 Cortex‑M3). Перечень групп инструкций приведён в разделе 8.
- Моделировать программную модель процессора: регистры R0–R15, xPSR, PRIMASK, FAULTMASK, BASEPRI, CONTROL, а также два указателя стека (MSP и PSP).
- Моделирование времени и тактирования (поцикловое исполнение):
    - Реализовать глобальный счетчик тактов (Cycle Counter), увеличивающийся после исполнения каждой инструкции.
    - Каждая инструкция должна потреблять определенное количество тактов (согласно справочнику PM0056 или упрощенной модели, например: 1 такт для большинства арифметических операций, 2+ для ветвлений и доступа к памяти).
    - Счетчик тактов ядра должен служить источником времени для периферийных блоков (таймеров), создавая детерминированную «иллюзию» хода времени.
- Обрабатывать прерывания в соответствии с моделью исключений Cortex‑M3: таблица векторов, приоритеты (фиксированные и конфигурируемые), автоматическое сохранение/восстановление контекста (stacking/unstacking), механизм EXC_RETURN.

#### 4.1.2. Периферийные блоки (Си)
- **GPIO (порты A, B, C…)**:
  - Реализовать регистры CRL, CRH, IDR, ODR, BSRR, BRR.
  - При записи в ODR/BSRR изменять внутреннее состояние; обеспечить возможность логирования изменений.
  - Чтение IDR должно позволять задавать значения из тестового окружения (внешний интерфейс симулятора).

- **Таймер общего назначения (TIM6)**:
  - Реализовать регистры CR1, SR, DIER, CNT, PSC, ARR.
  - При достижении условия (переполнение / совпадение) генерировать событие и, если разрешено, запрос прерывания.

- **UART (USART1)**:
  - Реализовать регистры SR, DR, BRR, CR1.
  - Передача: запись в DR выводит байт во внешний канал (консоль, лог‑файл или микросервис). Устанавливать флаг TXE и, при необходимости, вызывать прерывание.
  - Приём: реализовать функцию внешнего ввода, позволяющую подать байт в симулятор (установка RXNE и прерывание).
- **NVIC (Nested Vectored Interrupt Controller)**:
  - Реализовать регистры ISER, ICER, ISPR, ICPR, IPR.
  - Обеспечить хранение состояний прерываний (pending, active, enabled) и их приоритетов.
  - Взаимодействие с ядром: при возникновении запроса от периферии устанавливать pending; ядро при проверке должно выбирать прерывание с наивысшим приоритетом и инициировать вход в исключение.

#### 4.1.3. Микросервис-оркестратор (язык Go)
- Подписаться на очередь заданий в **KeyDB** (совместимое с Redis хранилище).
- Каждое задание должно содержать идентификатор и бинарный код прошивки (или ссылку на него).
- Запускать экземпляр ядра симулятора (как отдельный процесс или поток) и передавать ему код.
- После завершения выполнения (или останова по таймауту) собирать результаты:
  - логи UART;
  - итоговое состояние GPIO;
  - статистику выполнения (количество инструкций, время, ошибки).
- Отправлять результаты обратно в KeyDB.
- Интегрировать сбор метрик и трейсов через **OpenTelemetry** (время обработки задания, количество ошибок и т.п.).

### 4.2. Требования к интерфейсам взаимодействия
- Ядро симулятора должно предоставлять API для управления (запуск, останов, чтение/запись памяти и регистров). API может быть реализован в виде набора функций для вызова из Go (через cgo) или через межпроцессное взаимодействие.
- Микросервис должен быть отделяем от ядра: возможность запуска ядра как самостоятельного приложения для отладки.
- Форматы сообщений KeyDB должны быть описаны (например, JSON) и допускать уточнение в процессе разработки.

### 4.3. Нефункциональные требования
- **Точность**: результаты выполнения программы должны совпадать с поведением реального микроконтроллера для типовых учебных примеров. Временнáя точность (количество тактов) не требуется, но логика работы прерываний и периферии должна быть корректной.
- **Производительность**: типовое задание (мигание светодиодом, вывод строки по UART) должно выполняться не дольше 2 секунд реального времени на современном процессоре.
- **Надёжность**: при ошибках в моделируемом коде (деление на ноль, недопустимый адрес) симулятор не должен аварийно завершаться — необходимо выдавать диагностику и завершать задачу с ошибкой.
- **Масштабируемость**: микросервис должен поддерживать одновременную обработку не менее n задач за счёт запуска нескольких экземпляров ядра.
- **Потребление памяти**: один экземпляр ядра — не более 50 МБ ОЗУ.

## 5. Состав системы

Проект включает следующие компоненты:
1. **Ядро симулятора** (C) — моделирует процессор, память и периферию.
2. **Микросервис-оркестратор** (Go) — обеспечивает интеграцию с KeyDB и управление жизненным циклом задач.
3. **Тестовое инструментальное обеспечение**:
   - модульные тесты для проверки отдельных инструкций и блоков;
   - интеграционные тесты для проверки взаимодействия ядра и периферии;
   - системные тесты для проверки полного цикла «задание → выполнение → результат».
4. **Документация**:
   - пояснительная записка (отчёт) в формате PDF;
   - база знаний в Obsidian (структурированные заметки по изученным технологиям и архитектуре);
   - исходные тексты в репозитории Git.

## 6. Характеристики системы

- Целевая платформа для симулятора: Linux (Ubuntu 20.04+ / Linux Mint) или Windows 10+ с WSL2.
- Поддержка одновременного выполнения до n (в зависимости от производительности железа) экземпляров ядра на серверной конфигурации.
- Возможность остановки задачи по таймауту (например, 5 секунд реального времени).
- Логирование событий через OpenTelemetry с возможностью настройки уровня детализации.

## 7. Этапы разработки (рекомендуемая последовательность)

Для эффективной работы предлагается следующий порядок реализации:

1. **Создание базового каркаса** — выделение памяти под Flash и SRAM, регистровый файл.
2. **Разработка ядра** — цикл fetch‑decode‑execute для минимального набора инструкций (NOP, MOV, ADD, SUB, B).
3. **Моделирование GPIO** — простейшая периферия с возможностью логирования изменений.
4. **Реализация NVIC и SysTick** — базовый механизм прерываний и таймер, проверка входа/выхода из обработчика.
5. **Добавление UART** — вывод данных, генерация прерываний.
6. **Расширение набора инструкций** до объёма, необходимого для выполнения типовых программ.
7. **Разработка микросервиса на Go** и интеграция с KeyDB.
8. **Тестирование и отладка** — покрытие тестами, сравнение с поведением реального железа.
9. **Подготовка документации и отчёта**.

## 8. Детализация системы команд

Симулятор должен поддерживать систему команд в соответствии с документом **PM0056** (STM32 Cortex‑M3 programming manual). Обязательные группы инструкций:

- **Доступ к памяти**: LDR, STR (все варианты размера и режимов адресации), LDM, STM, PUSH, POP, LDREX/STREX.
- **Арифметические и логические**: ADD, ADC, SUB, SBC, RSB, MUL, SDIV, UDIV, AND, ORR, EOR, BIC, ORN, сдвиги (ASR, LSL, LSR, ROR, RRX).
- **Сравнение и переходы**: CMP, CMN, TST, TEQ, B (с условиями), BL, BX, BLX, CBZ, CBNZ, IT, TBB/TBH.
- **Перемещение данных**: MOV, MVN, MOVT, CLZ, REV/REV16/REVSH/RBIT.
- **Битовые операции**: BFC, BFI, SBFX, UBFX, SXTB/SXTH, UXTB/UXTH.
- **Насыщение**: SSAT, USAT.
- **Системные и специальные**: MRS, MSR, SVC, CPS, BKPT, NOP, SEV, WFE, WFI, барьеры (DMB, DSB, ISB).

Полный перечень и описание каждой инструкции приведены в Table 20 (стр. 44–49) PM0056.

## 9. Требования к документации и отчёту

- Отчёт в формате PDF должен содержать:
  - титульный лист с названием проекта, ФИО авторов, руководителем, организацией и годом;
  - оглавление;
  - введение (актуальность, цели, задачи);
  - техническое задание (настоящий документ);
  - описание архитектуры системы;
  - описание реализации (структуры, ключевые алгоритмы, интерфейсы);
  - описание системы тестирования;
  - заключение (полученные результаты, выводы);
  - список литературы (включая ГОСТ и официальную документацию).
- База знаний в Obsidian: заметки по каждой теме (инструкции, регистры, периферия) с внутренними ссылками.
- Исходные тексты проекта предоставляются в виде архива репозитория Git (ссылку или .zip).
- Презентация проекта (краткий обзор основных решений и результатов).

## 10. Заключение

Данное техническое задание определяет необходимый и достаточный объём работ для создания симулятора микроконтроллера STM32F103C8T6 в рамках учебного проекта. Выполнение требований гарантирует получение работающего продукта, пригодного для использования в лабораторном практикуме и демонстрирующего понимание архитектуры встроенных систем.

